name: Build apk Package, Docker image and Release Triggered for major and minor Versions

on:
  workflow_call:
    inputs:
      version:
        description: 'Version (without leading v). If omitted, read from package.json.'
        required: false
        type: string
    outputs:
      resolved_version:
        description: 'Resolved version used for tagging.'
        value: ${{ jobs.prepare.outputs.resolved_version }}
      image_tag:
        description: 'Docker image tag (v<version>).'
        value: ${{ jobs.docker.outputs.image_tag }}
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (without leading v). If omitted, read from package.json.'
        required: false
        type: string
env:
  product_name: modbus2mqtt
  main_docker_name: 'ghcr.io/${{ github.repository_owner }}/modbus2mqtt'
jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      resolved_version: ${{ steps.setver.outputs.resolved_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Read version
        id: setver
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            echo "resolved_version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            PKG_VERSION=$(python3 -c "import json;print(json.load(open('package.json'))['version'])")
            echo "resolved_version=$PKG_VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT)"

  build_apks:
    runs-on: ${{ matrix.platform }}
    environment: packager
    needs: prepare
    permissions:
      packages: write      
    strategy:
      matrix:
        platform: [ubuntu-latest, ubuntu-22.04-arm]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      #      The "Set Platform specific Attributes" original to be copied below!!
      - name: Set Platform specific Attributes
        id: platformattributes
        run: |
          if [ "${{ matrix.platform }}" == "ubuntu-22.04-arm" ]; then
            echo "arch=aarch64" >> $GITHUB_OUTPUT
            platform=arm64
          else
            echo "arch=x86_64" >> $GITHUB_OUTPUT
            platform=amd64
          fi
          echo "platform=$platform" >> $GITHUB_OUTPUT
          echo "platform=\"$platform\""
          docker_name=$main_docker_name-$platform:${{ needs.prepare.outputs.resolved_version }}
          echo "docker_name_version=\"$docker_name_version\""
          echo "docker_name_version=$docker_name_version" >> $GITHUB_OUTPUT

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq bash

      - name: Build APK for ${{ steps.platformattributes.outputs.arch }}
        env:
          ALPINE_ARCH: ${{ steps.platformattributes.outputs.arch }}
          TARGET_ARCH: ${{ steps.platformattributes.outputs.arch }}
          PACKAGER_PRIVKEY: ${{ secrets.PACKAGER_PRIVKEY }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -eux
          # Build APK using package.sh (no QEMU needed - native execution)
          echo "Building APK for ${{ steps.platformattributes.outputs.arch }} on native runner..."
          alpine/package/$product_name/package.sh
          echo "âœ“ APK build completed for ${{ steps.platformattributes.outputs.arch }}"

          # Verify APK creation
          echo "Verifying APK creation for ${{ steps.platformattributes.outputs.arch }}..."
          if [ -d "alpine/repo/${{ steps.platformattributes.outputs.arch }}" ]; then
            echo "âœ“ Architecture directory exists: alpine/repo/${{ steps.platformattributes.outputs.arch }}"
            ls -la "alpine/repo/${{ steps.platformattributes.outputs.arch }}/" || true
            apk_count=$(find "alpine/repo/${{ steps.platformattributes.outputs.arch }}" -name "*.apk" | wc -l)
            echo "Found $apk_count APK files for ${{ steps.platformattributes.outputs.arch }}"
          else
            echo "ERROR: Architecture directory alpine/repo/${{ steps.platformattributes.outputs.arch }} not found!"
            echo "Available directories:"
            ls -la alpine/repo/ || true
            exit 1
          fi

      - name: Debug APK structure before upload
        run: |
          echo "Checking APK structure for ${{ steps.platformattributes.outputs.arch }}..."
          ls -laR alpine/repo/ || echo "alpine/repo not found"
          find . -name "*.apk" -type f || echo "No APK files found"
      - name: Prepare APK filenames (append arch suffix)
        run: |
          set -euo pipefail
          ARCH=${{ steps.platformattributes.outputs.arch }}
          SRC_DIR="alpine/repo/${ARCH}"
          DST_DIR="alpine/repo/upload"
          mkdir -p "$DST_DIR"
          shopt -s nullglob || true
          for f in "$SRC_DIR"/*.apk; do
            [ -f "$f" ] || continue
            base=$(basename "$f")
            # If filename already contains arch indicators, keep it, else append
            if echo "$base" | grep -Eq "(x86_64|aarch64|amd64|arm64)"; then
              cp "$f" "$DST_DIR/$base"
            else
              cp "$f" "$DST_DIR/${base%.apk}-$ARCH.apk"
            fi
          done
          ls -lh "$DST_DIR" || true

      - name: Upload APK artifacts for ${{ steps.platformattributes.outputs.arch }}
        uses: actions/upload-artifact@v4
        with:
          name: apks-${{ steps.platformattributes.outputs.arch }}-${{ needs.prepare.outputs.resolved_version }}
          path: alpine/repo/upload/*.apk
          if-no-files-found: error

      - name: Upload packager.rsa.pub as separate artifact
        if: steps.platformattributes.outputs.arch == 'x86_64' # Nur einmal hochladen (z. B. im x86_64-Job)
        uses: actions/upload-artifact@v4
        with:
          name: packager-rsa-pub-${{ needs.prepare.outputs.resolved_version }}
          path: alpine/repo/packager.rsa.pub
          if-no-files-found: error

  build_and_push_docker:
    runs-on: ${{ matrix.platform }}
    needs: [prepare, build_apks]
    permissions:
      packages: write
    strategy:
      matrix:
        platform: [ubuntu-latest, ubuntu-22.04-arm]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      #      The "Set Platform specific Attributes" , must to be copied from original !!
      - name: Set Platform specific Attributes
        id: platformattributes
        run: |
          if [ "${{ matrix.platform }}" == "ubuntu-22.04-arm" ]; then
            echo "arch=aarch64" >> $GITHUB_OUTPUT
            platform=arm64
          else
            echo "arch=x86_64" >> $GITHUB_OUTPUT
            platform=amd64
          fi
          echo "platform=$platform" >> $GITHUB_OUTPUT
          echo "platform=\"$platform\""
          docker_name_version=$main_docker_name-$platform:${{ needs.prepare.outputs.resolved_version }}
          echo "docker_name_version=\"$docker_name_version\""
          echo "docker_name_version=$docker_name_version" >> $GITHUB_OUTPUT

      - name: Download APK artifacts for ${{ steps.platformattributes.outputs.arch }}
        uses: actions/download-artifact@v4
        with:
          name: apks-${{ steps.platformattributes.outputs.arch }}-${{ needs.prepare.outputs.resolved_version }}
          path: alpine/repo/${{ steps.platformattributes.outputs.arch }}

      - name: Download packager.rsa.pub artifact
        uses: actions/download-artifact@v4
        with:
          name: packager-rsa-pub-${{ needs.prepare.outputs.resolved_version }}
          path: alpine/repo/

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image for ${{ steps.platformattributes.outputs.platform }}
        env:
          VERSION: ${{ needs.prepare.outputs.resolved_version }}
          ARCH: ${{ steps.platformattributes.outputs.arch }}
          PLATFORM: ${{ steps.platformattributes.outputs.platform }}
        run: |
          set -eux

          echo "Building Docker image for $PLATFORM architecture..."
          docker build \
            --build-arg BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --build-arg BUILD_DESCRIPTION="$product_name Docker Image" \
            --build-arg BUILD_NAME="$product_name" \
            --build-arg BUILD_REPOSITORY="${{ github.repository }}" \
            --build-arg BUILD_VERSION="${VERSION}" \
            --build-arg BUILD_ARCH="${ARCH}" \
            -t "${{ steps.platformattributes.outputs.docker_name_version }}" \
            -f ./docker/Dockerfile \
            .

          echo "Pushing image: ${{ steps.platformattributes.outputs.docker_name_version }}"
          docker push "${{ steps.platformattributes.outputs.docker_name_version }}"
          echo "âœ“ Built and pushed image  ${{ steps.platformattributes.outputs.docker_name_version }}"

      - name: Test native Docker image (only on amd64/x86_64)
        if: steps.platformattributes.outputs.platform == 'amd64'
        run: |
          set -eux
          docker images
          local_image=$main_docker_name-${{ steps.platformattributes.outputs.platform }}
          # Even if the local file is available, this is required before docker run
          docker pull "${{ steps.platformattributes.outputs.docker_name_version }}"
          ./docker/test.sh --quick --docker-tag "${{ steps.platformattributes.outputs.docker_name_version }}"
          echo "âœ“ Docker-Image wurde erfolgreich getestet."

  create_multiarch_manifest:
    runs-on: ubuntu-latest
    permissions:
      packages: write  
    needs: [prepare, build_and_push_docker]
    outputs:
      image_tag: v${{ needs.prepare.outputs.resolved_version }}
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create multi-architecture manifest
        env:
          VERSION: ${{ needs.prepare.outputs.resolved_version }}
        run: |
          set -eux
          MAIN_TAG="$main_docker_name:${{ needs.prepare.outputs.resolved_version }}"
          AMD64_TAG="$main_docker_name-amd64:${{ needs.prepare.outputs.resolved_version }}"
          ARM64_TAG="$main_docker_name-arm64:${{ needs.prepare.outputs.resolved_version }}"

          echo "Creating multi-architecture manifest: $MAIN_TAG"
          docker buildx imagetools create -t "$MAIN_TAG" "$AMD64_TAG" "$ARM64_TAG"
          docker buildx imagetools create -t "$main_docker_name:latest" "$AMD64_TAG" "$ARM64_TAG"
          docker buildx imagetools create -t "$main_docker_name-amd64:latest" "$AMD64_TAG" 
          docker buildx imagetools create -t "$main_docker_name-arm64:latest" "$ARM64_TAG" 

          echo "âœ“ Created multi-architecture manifest: $MAIN_TAG"

  attach_release_assets:
    runs-on: ubuntu-latest
    needs: [prepare, build_apks, create_multiarch_manifest]
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Download all APK artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: apks-*-${{ needs.prepare.outputs.resolved_version }}
          path: apks
      - name: Download packager.rsa.pub artifact
        uses: actions/download-artifact@v4
        with:
          name: packager-rsa-pub-${{ needs.prepare.outputs.resolved_version }}
          path: release-apks/

      - name: Flatten APK artifacts for upload
        run: |
          mkdir -p release-apks
          find apks -type f \( -name "*.apk" -o -name "packager.rsa.pub" \) -exec cp {} release-apks/ \;
          ls -lh release-apks/

      - name: Generate GitHub changelog (initial-release-notes.md)
        run: |
          TAG="v${{ needs.prepare.outputs.resolved_version }}"
          API="https://api.github.com/repos/${{ github.repository }}/releases/generate-notes"
          echo "Requesting generated release notes for $TAG"
          RESPONSE=$(curl -s -H "Accept: application/vnd.github+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -X POST -d "{\"tag_name\":\"$TAG\"}" "$API")
          echo "$RESPONSE" | python3 -c "import sys,json; print(json.load(sys.stdin).get('body',''))" > initial-release-notes.md || true
          if [ ! -s initial-release-notes.md ]; then
            echo "## Changelog" > initial-release-notes.md
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate release body with APK table
        id: release-body
        run: |
          VERSION="${{ needs.prepare.outputs.resolved_version }}"
          DOCKER_TAG="$main_docker_name:v${VERSION}"

          # FÃ¼ge GitHub-Changelog (initial-release-notes.md) am Anfang ein
          if [ -f initial-release-notes.md ]; then
            # FÃ¼ge eine Leerzeile nach dem Changelog ein, damit Markdown-Header korrekt erkannt werden
            cat initial-release-notes.md > release-body.md
            echo >> release-body.md
          fi

          # Create release body mit APK-Tabelle
          cat >> release-body.md << 'EOF'
          ## ðŸ“¦ $product_name v${{ needs.prepare.outputs.resolved_version }}

          ### ðŸ³ Docker Image

          ```bash
          docker pull ghcr.io/${{ github.repository }}:v${{ needs.prepare.outputs.resolved_version }}
          ```
                    
          **Multi-architecture support:** `linux/amd64`, `linux/arm64`

          ### ðŸ“‹ Alpine APK Packages

          EOF

          # Nur einen Eintrag fÃ¼r x86_64 APK erzeugen
          APK_FILE=$(ls release-apks/*x86_64*.apk 2>/dev/null | head -n1 || true)
          if [ -n "$APK_FILE" ]; then
            FILENAME=$(basename "$APK_FILE")
            SIZE=$(ls -lh "$APK_FILE" | awk '{print $5}')
            DOWNLOAD_LINK="[ðŸ“¥ Download](https://github.com/${{ github.repository }}/releases/download/v${VERSION}/${FILENAME})"
            echo "$product_name x86_64 (AMD64) Size: `$FILENAME\\` $SIZE    $DOWNLOAD_LINK" >> release-body.md
          else
            echo "amd64notfound=true" >> $GITHUB_OUTPUT
          fi

          # Add public key section

          cat >> release-body.md << 'EOF'

          ### ðŸ” Package Verification

          **Public Key for APK signature verification:**

          | File | Purpose | Download |
          |------|---------|----------|
          | `packager.rsa.pub` | APK signature verification | [ðŸ“¥ Download](https://github.com/${{ github.repository }}/releases/download/v${{ needs.prepare.outputs.resolved_version }}/packager.rsa.pub) |

          **Installation with signature verification:**

          ```bash
          # Download and install public key
          wget https://github.com/${{ github.repository }}/releases/download/v${{ needs.prepare.outputs.resolved_version }}/packager.rsa.pub
          sudo cp packager.rsa.pub /etc/apk/keys/

          # Install APK with verification
          # for aarch64 uncomment the following line and comment the x86_64 line
          # wget https://github.com/${{ github.repository }}/releases/download/v${{ needs.prepare.outputs.resolved_version }}/$product_name-${{ needs.prepare.outputs.resolved_version }}-r0-aarch64.apk
          wget https://github.com/${{ github.repository }}/releases/download/v${{ needs.prepare.outputs.resolved_version }}/$product_name-${{ needs.prepare.outputs.resolved_version }}-r0-x86_64.apk
          apk add $product_name-${{ needs.prepare.outputs.resolved_version }}-r0.apk
          ```

          ### ðŸš€ Quick Start

          **Docker (Recommended):**
          ```bash
          docker run -d \
            --name ${{ env.product_name }}\
            -p 3000:3000 \
            -v /path/to/config:/data \
            ${{ env.main_docker_name }}:${{ needs.prepare.outputs.resolved_version }}
          ```

          ---

          ðŸ“š **Documentation:** [README.md](https://github.com/${{ github.repository }}/blob/main/README.md)  
          ðŸ› **Issues:** [Report bugs](https://github.com/${{ github.repository }}/issues)  
          ðŸ’¬ **Discussions:** [Community support](https://github.com/${{ github.repository }}/discussions)
          EOF

          echo "Release body generated successfully"

      - name: Upload to existing Release (if exists)
        if: ${{ steps.release-body.outputs.amd64notfound != 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.resolved_version }}
          append_body: false
          body_path: release-body.md
          files: release-apks/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  update_hassio_addon_version:
    runs-on: ubuntu-latest
    needs: [prepare, build_apks, create_multiarch_manifest]
    environment: release
    steps:
      - name: Checkout modbus2mqtt Repository
        uses: actions/checkout@v5
  
      - name: Checkout  hassio-addon-repository
        uses: actions/checkout@v5
        with:
          repository: ${{ github.repository_owner}}/hassio-addon-repository
          path: hassio-addon-repository
          ref: refs/heads/main
          token: ${{ secrets.PAT }}
      - name: Update Version in config.yaml
        id: updateVersion
        run: |
          sed -i -e 's/version: .*/version: ${{ needs.prepare.outputs.resolved_version }}/g' \
          -e 's|image: .*|image: ${{ env.main_docker_name }}|g' \
          -e 's|\(url: https://github.com/\)[^/]*\/[^/]*\(.*\)|\1${{github.repository}}\2|g' \
          hassio-addon-repository/${{ env.product_name }}/config.yaml
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: 'âœï¸ Generate changelog History'
        uses: heinrichreimer/action-github-changelog-generator@v2.4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          output: hassio-addon-repository/${{ env.product_name }}/CHANGELOG.md
          headerLabel: '## Changelog for Modbus <=> MQTT'
      - name: Checkin hassio-addon-repository
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: ${{ needs.prepare.outputs.resolved_version }}
          repository: hassio-addon-repository
# Notes:
# - dry_run=true allows local verification without pushing image or release assets.
# - Multi-arch APK builds (x86_64 + aarch64) use QEMU for cross-compilation.
# - Docker image builds with strict signature verification (no untrusted fallback).
# - This workflow is designed to be called from a publish workflow after version bump.
