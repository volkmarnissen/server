name: Build Release Assets

on:
  workflow_call:
    inputs:
      version:
        description: 'Version (without leading v). If omitted, read from package.json.'
        required: false
        type: string
    outputs:
      resolved_version:
        description: 'Resolved version used for tagging.'
        value: ${{ jobs.prepare.outputs.resolved_version }}
      image_tag:
        description: 'Docker image tag (v<version>).'
        value: ${{ jobs.docker.outputs.image_tag }}
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (without leading v). If omitted, read from package.json.'
        required: false
        type: string
jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      resolved_version: ${{ steps.setver.outputs.resolved_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Read version
        id: setver
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            echo "resolved_version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            PKG_VERSION=$(python3 -c "import json;print(json.load(open('package.json'))['version'])")
            echo "resolved_version=$PKG_VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT)"

  build_apks:
    runs-on: ubuntu-latest
    environment: packager
    needs: prepare
    strategy:
      matrix:
        arch: [x86_64, aarch64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU for cross-compilation
        if: matrix.arch == 'aarch64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq bash

      - name: Build APK for ${{ matrix.arch }}
        env:
          ALPINE_ARCH: ${{ matrix.arch }}
          PACKAGER_PRIVKEY: ${{ secrets.PACKAGER_PRIVKEY }}
        run: |
          set -eux
          cd alpine/package/modbus2mqtt
          # For aarch64, use QEMU to run the Alpine container on arm64
          if [ "$ALPINE_ARCH" = "aarch64" ]; then
            # Build APK only (skip Docker test on emulated arch for speed)
            echo "Building APK for aarch64 with QEMU emulation..."
            ./build.sh
            echo "‚úì APK build completed for aarch64"
          else
            # For x86_64, run full build-and-test including Docker validation
            echo "Building and testing APK for x86_64..."
            ./build-and-test-image.sh
            echo "‚úì APK build and test completed for x86_64"
          fi
          
          # Verify APK creation
          echo "Verifying APK creation for $ALPINE_ARCH..."
          if [ -d "../../repo/$ALPINE_ARCH" ]; then
            echo "‚úì Architecture directory exists: ../../repo/$ALPINE_ARCH"
            ls -la "../../repo/$ALPINE_ARCH"/ || true
            apk_count=$(find "../../repo/$ALPINE_ARCH" -name "*.apk" | wc -l)
            echo "Found $apk_count APK files for $ALPINE_ARCH"
          else
            echo "ERROR: Architecture directory ../../repo/$ALPINE_ARCH not found!"
            echo "Available directories:"
            ls -la ../../repo/ || true
            exit 1
          fi

      - name: Debug APK structure before upload
        run: |
          echo "Checking APK structure for ${{ matrix.arch }}..."
          ls -laR alpine/repo/ || echo "alpine/repo not found"
          find . -name "*.apk" -type f || echo "No APK files found"
          
      - name: Upload APK artifacts for ${{ matrix.arch }}
        uses: actions/upload-artifact@v4
        with:
          name: apks-${{ matrix.arch }}-${{ needs.prepare.outputs.resolved_version }}
          path: |
            alpine/repo/${{ matrix.arch }}/*.apk
            alpine/repo/packager.rsa.pub
          if-no-files-found: error

  docker:
    runs-on: ubuntu-latest
    needs: [prepare, build_apks]
    outputs:
      image_tag: v${{ needs.prepare.outputs.resolved_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all APK artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: apks-*-${{ needs.prepare.outputs.resolved_version }}
          path: downloaded-apks

      - name: Organize APKs by architecture
        run: |
          mkdir -p alpine/repo
          # Move artifacts from their subdirectories to alpine/repo/<arch>/
          PUBLIC_KEY_COPIED=false
          for artifact_dir in downloaded-apks/apks-*; do
            if [ -d "$artifact_dir" ]; then
              # Extract architecture from artifact directory name
              dir_basename=$(basename "$artifact_dir")
              echo "Debug: Processing directory: $dir_basename"
              ARCH=$(echo "$dir_basename" | sed 's/apks-\([^-]*\)-.*/\1/')
              echo "‚úì Extracted architecture: '$ARCH' from '$dir_basename'"
              mkdir -p "alpine/repo/$ARCH"
              
              # Copy APK files to arch directory
              find "$artifact_dir" -name "*.apk" -exec cp {} "alpine/repo/$ARCH/" \;
              echo "‚úì Copied APK files for $ARCH"
              
              # Copy public key to repo root (only once)
              if [ "$PUBLIC_KEY_COPIED" = "false" ] && [ -f "$artifact_dir/packager.rsa.pub" ]; then
                cp "$artifact_dir/packager.rsa.pub" "alpine/repo/packager.rsa.pub"
                echo "‚úì Public key copied to alpine/repo/packager.rsa.pub"
                PUBLIC_KEY_COPIED=true
              fi
            fi
          done
          
          # Ensure we have APKs for both architectures
          echo "Checking APK availability:"
          for arch in x86_64 aarch64; do
            if [ -d "alpine/repo/$arch" ]; then
              apk_count=$(find "alpine/repo/$arch" -name "*.apk" | wc -l)
              echo "‚úì $arch: $apk_count APK files"
              ls -la "alpine/repo/$arch"/*.apk || true
            else
              echo "‚ö†Ô∏è  Missing APKs for $arch"
            fi
          done
          
          # Verify the structure
          echo "Final alpine/repo structure:"
          ls -lR alpine/repo

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: amd64,arm64

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build (and optionally push) multi-arch image
        id: buildimage
        env:
          VERSION: ${{ needs.prepare.outputs.resolved_version }}
        run: |
          set -eux
          TAG="ghcr.io/${{ github.repository }}:v${VERSION}"
          # Production: build and push multi-arch with layer caching
          docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --cache-from type=gha \
          --cache-to type=gha,mode=max \
          --build-arg BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
          --build-arg BUILD_DESCRIPTION="modbus2mqtt Docker Image" \
          --build-arg BUILD_NAME="modbus2mqtt" \
          --build-arg BUILD_REPOSITORY="${{ github.repository }}" \
          --build-arg BUILD_VERSION="${VERSION}" \
          -t "$TAG" \
          --progress plain \
          --push \
          -f ./docker/Dockerfile \
          .
          echo "Built image $TAG"

  attach_release_assets:
    runs-on: ubuntu-latest
    needs: [prepare, build_apks, docker]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all APK artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: apks-*-${{ needs.prepare.outputs.resolved_version }}
          path: apks

      - name: Flatten APK artifacts for upload
        run: |
          mkdir -p release-apks
          find apks -type f \( -name "*.apk" -o -name "packager.rsa.pub" \) -exec cp {} release-apks/ \;
          ls -lh release-apks/

      - name: Generate release body with APK table
        id: release-body
        run: |
          VERSION="${{ needs.prepare.outputs.resolved_version }}"
          DOCKER_TAG="ghcr.io/${{ github.repository }}:v${VERSION}"
          
          # Create release body with APK table
          cat > release-body.md << 'EOF'
          ## üì¶ modbus2mqtt v${{ needs.prepare.outputs.resolved_version }}
          
          ### üê≥ Docker Image
          
          ```bash
          docker pull ghcr.io/${{ github.repository }}:v${{ needs.prepare.outputs.resolved_version }}
          ```
          
          **Multi-architecture support:** `linux/amd64`, `linux/arm64`
          
          ### üìã Alpine APK Packages
          
          | Architecture | APK Package | Size | Direct Download |
          |--------------|-------------|------|-----------------|
          EOF
          
          # Add APK files to table
          for apk_file in release-apks/*.apk; do
            if [ -f "$apk_file" ]; then
              FILENAME=$(basename "$apk_file")
              # Extract architecture from filename pattern
              if echo "$FILENAME" | grep -q "x86_64"; then
                ARCH="x86_64 (AMD64)"
              elif echo "$FILENAME" | grep -q "aarch64"; then
                ARCH="aarch64 (ARM64)"
              else
                ARCH="Unknown"
              fi
              # Get file size
              SIZE=$(ls -lh "$apk_file" | awk '{print $5}')
              # Create download link
              DOWNLOAD_LINK="[üì• Download](https://github.com/${{ github.repository }}/releases/download/v${VERSION}/${FILENAME})"
              
              echo "| $ARCH | \`$FILENAME\` | $SIZE | $DOWNLOAD_LINK |" >> release-body.md
            fi
          done
          
          # Add public key section
          cat >> release-body.md << 'EOF'
          
          ### üîê Package Verification
          
          **Public Key for APK signature verification:**
          
          | File | Purpose | Download |
          |------|---------|----------|
          | `packager.rsa.pub` | APK signature verification | [üì• Download](https://github.com/${{ github.repository }}/releases/download/v${{ needs.prepare.outputs.resolved_version }}/packager.rsa.pub) |
          
          **Installation with signature verification:**
          
          ```bash
          # Download and install public key
          wget https://github.com/${{ github.repository }}/releases/download/v${{ needs.prepare.outputs.resolved_version }}/packager.rsa.pub
          sudo cp packager.rsa.pub /etc/apk/keys/
          
          # Install APK with verification
          wget https://github.com/${{ github.repository }}/releases/download/v${{ needs.prepare.outputs.resolved_version }}/modbus2mqtt-${{ needs.prepare.outputs.resolved_version }}-r0.apk
          apk add modbus2mqtt-${{ needs.prepare.outputs.resolved_version }}-r0.apk
          ```
          
          ### üöÄ Quick Start
          
          **Docker (Recommended):**
          ```bash
          docker run -d \
            --name modbus2mqtt \
            -p 3000:3000 \
            -p 22:22 \
            -v /path/to/config:/data \
            ghcr.io/${{ github.repository }}:v${{ needs.prepare.outputs.resolved_version }}
          ```
          
          **Alpine Linux:**
          ```bash
          # Add repository and install
          echo "https://github.com/${{ github.repository }}/releases/download/v${{ needs.prepare.outputs.resolved_version }}/" >> /etc/apk/repositories
          apk update
          apk add modbus2mqtt
          ```
          
          ---
          
          üìö **Documentation:** [README.md](https://github.com/${{ github.repository }}/blob/main/README.md)  
          üêõ **Issues:** [Report bugs](https://github.com/${{ github.repository }}/issues)  
          üí¨ **Discussions:** [Community support](https://github.com/${{ github.repository }}/discussions)
          EOF
          
          echo "Release body generated successfully"

      - name: Upload to existing Release (if exists)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.resolved_version }}
          append_body: true
          body_path: release-body.md
          files: release-apks/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

# Notes:
# - dry_run=true allows local verification without pushing image or release assets.
# - Multi-arch APK builds (x86_64 + aarch64) use QEMU for cross-compilation.
# - Docker image builds with strict signature verification (no untrusted fallback).
# - This workflow is designed to be called from a publish workflow after version bump.
