#!/usr/bin/env bash
set -euo pipefail
# Consolidated pre-commit hook
# - Enforces APKBUILD contains npmpackage="${pkgname}" (mandatory)
# - Warns if package.json name/version changed (commit-msg enforces it and honors skip token)
# - Runs prettier on staged files and requests re-stage if formatting changed

echo "[pre-commit] Starting checks..."

get_index_file() {
  # Return staged (index) version of a file if available, else fall back to worktree file
  local path="$1"
  if git rev-parse --verify --quiet ":$path" >/dev/null; then
    git show ":$path" 2>/dev/null || true
  else
    cat "$path" 2>/dev/null || true
  fi
}

echo "[pre-commit] Checking APKBUILD..."
APK_PATH="alpine/package/modbus2mqtt/APKBUILD"
apk_content=$(get_index_file "$APK_PATH")
apk_len=${#apk_content}
echo "[pre-commit] APKBUILD content length: $apk_len"

if ! printf '%s' "$apk_content" | grep -F 'npmpackage="${pkgname}"' >/dev/null 2>&1; then
  echo "ERROR: $APK_PATH must contain npmpackage=\"\\${pkgname}\"" >&2
  echo "Commit aborted by pre-commit hook. If you must bypass, include [skip-apkbuild-check] in the commit message — commit-msg will honor it." >&2
  exit 1
fi
echo "[pre-commit] APKBUILD check passed."

# Warn about package.json changes (commit-msg enforces with skip token)
echo "[pre-commit] Checking staged package.json (warning only)..."
STAGED_FILES=$(git diff --cached --name-only || true)
if echo "$STAGED_FILES" | grep -qx "package.json"; then
  # Safely read package.json from HEAD (if HEAD exists) and from index. Avoid piping that can trigger
  # set -e due to pipefail by capturing output first and then parsing with python.
  v_head_json=$(git show HEAD:package.json 2>/dev/null || true)
  v_index_json=$(git show :package.json 2>/dev/null || true)

  if [ -n "$v_head_json" ]; then
    v_head=$(printf '%s' "$v_head_json" | python3 -c 'import sys, json
data=sys.stdin.read()
try:
    print(json.loads(data).get("version",""))
except Exception:
    print("")') || true
    n_head=$(printf '%s' "$v_head_json" | python3 -c 'import sys, json
data=sys.stdin.read()
try:
    print(json.loads(data).get("name",""))
except Exception:
    print("")') || true
  else
    v_head=""
    n_head=""
  fi

  if [ -n "$v_index_json" ]; then
    v_index=$(printf '%s' "$v_index_json" | python3 -c 'import sys, json
data=sys.stdin.read()
try:
    print(json.loads(data).get("version",""))
except Exception:
    print("")') || true
    n_index=$(printf '%s' "$v_index_json" | python3 -c 'import sys, json
data=sys.stdin.read()
try:
    print(json.loads(data).get("name",""))
except Exception:
    print("")') || true
  else
    v_index=""
    n_index=""
  fi

  if [ "$v_head" != "$v_index" ] || [ "$n_head" != "$n_index" ]; then
    echo "[pre-commit] WARNING: 'package.json' 'version' or 'name' is changed in staged files." >&2
    echo "[pre-commit] The commit-msg hook will enforce this check and supports [skip-version-name-check] in the commit message to bypass when intentional." >&2
  else
    echo "[pre-commit] package.json unchanged." >&2
  fi
fi

# Run prettier on staged files (only certain extensions)
echo "[pre-commit] Running prettier on staged files (if any)..."
STAGED_FORMAT_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|tsx|js|jsx|css|html)$' || true)
if [ -n "$STAGED_FORMAT_FILES" ]; then
  echo "[pre-commit] Files to format:" && printf '%s\n' "$STAGED_FORMAT_FILES" && echo
  # Run prettier via npm script to preserve project config, capture output
  PRETTIER_OUTPUT=$(printf '%s\n' "$STAGED_FORMAT_FILES" | xargs -r npm run prettier)

  # If prettier changed files, add them back to index and abort commit so user can review
  if ! git diff --quiet; then
    echo "$PRETTIER_OUTPUT"
    echo "[pre-commit] Prettier modified files. Bitte prüfe und stage die Änderungen vor dem Commit." >&2
    # Stage the files that were formatted (best-effort)
    echo "$STAGED_FORMAT_FILES" | xargs -r git add || true
    echo "[pre-commit] Staged formatted files. Aborting commit so you can verify changes." >&2
    exit 1
  fi
else
  echo "[pre-commit] No files to format." >&2
fi

# Block commits with forbidden file extensions for ESM projects
forbidden_exts="cjs cts js ts tsx"
for file in $STAGED_FILES; do
  ext="${file##*.}"
  for forbidden in $forbidden_exts; do
    if [ "$ext" = "$forbidden" ]; then
      echo "[pre-commit] ERROR: File extension .$forbidden is not allowed in this ESM project: $file" >&2
      echo "[pre-commit] Commit aborted due to forbidden file extension." >&2
      exit 1
    fi
  done
done

# Check for non-English text in staged files (only code/text files)
NON_ENGLISH_FOUND=0
for file in $STAGED_FILES; do
  case "$file" in
    *.mjs|*.mts|*.sh|*.md|*.html|*.css|*.json|*.yml|*.yaml)
      # Check for non-ASCII and non-standard English chars (allow common code symbols)
      if LC_ALL=C grep -P '[^\x00-\x7F]' "$file" >/dev/null; then
        echo "[pre-commit] ERROR: Non-English (non-ASCII) text found in $file. Please use only English in code and documentation." >&2
        NON_ENGLISH_FOUND=1
      fi
      ;;
  esac
done
if [ "$NON_ENGLISH_FOUND" -eq 1 ]; then
  echo "[pre-commit] Commit aborted due to non-English text." >&2
  exit 1
fi

echo "[pre-commit] All checks passed." >&2
exit 0
